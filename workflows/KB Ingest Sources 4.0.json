{
  "name": "KB Ingest Sources 4.0",
  "nodes": [
    {
      "parameters": {
        "command": "=mkdir -p /data/tmp && \\\nMETA=\"/data/tmp/meta_{{$json.source_id}}.json\" && \\\nOUT=\"/data/tmp/kb_{{$json.source_id}}.json\" && \\\nERR=\"/data/tmp/kb_{{$json.source_id}}.err\" && \\\ncat > \"$META\" <<'PYDATA'\n{{ JSON.stringify({\n  source_id: $json.source_id,\n  source_name: $json.source_name,\n  file_name: $json.file_name,\n  file_path: $json.file_path,\n  dest_path: $json.dest_path,\n  extension: $json.extension,\n  source_path: $json.source_path\n}) }}\nPYDATA\npython3 - <<'PY' \"$META\" || { echo \"Bad metadata JSON in $META\" >&2; exit 1; }\nimport sys, json\nwith open(sys.argv[1],'r',encoding='utf-8') as f:\n    json.load(f)\nprint(\"OK\", file=sys.stderr)\nPY\npython3 /data/scripts/extract_kb_clinical_guides.py < \"$META\" > \"$OUT\" 2> \"$ERR\" && \\\necho \"{\\\"file\\\":\\\"$OUT\\\",\\\"source_id\\\":{{$json.source_id}}}\" || \\\n( echo \"Extractor failed, see $ERR\" >&2; exit 1 )\n"
      },
      "id": "752af033-07e8-44ef-a59d-e627e0c17d15",
      "name": "Extract & Chunk",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1072,
        16
      ]
    },
    {
      "parameters": {
        "functionCode": "// Lee el puntero que dejó el extractor\nconst out = JSON.parse($json.stdout || '{}');\nif (!out.file) throw new Error('Extractor no devolvió ruta (out.file)');\nreturn [{ json: { file: out.file, source_id: out.source_id } }];\n"
      },
      "id": "f489cf4d-2101-4953-9aa5-bd059ac474cb",
      "name": "Prepare Chunk Payload",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1232,
        32
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH payload AS (\n  SELECT\n    {{ $json.source_id }}::int AS source_id,\n    '{{ JSON.stringify($json.chunks_json) }}'::jsonb AS chunks_json\n),\nexpanded AS (\n  SELECT\n    payload.source_id,\n    COALESCE((chunk.value->>'chunk_index')::int, chunk.ordinality::int) AS chunk_index,\n    GREATEST(1, COALESCE((chunk.value->>'page_number')::int, 1)) AS page_number,\n    NULLIF(chunk.value->>'content', '') AS content,\n    CASE\n      WHEN chunk.value ? 'embedding' AND jsonb_typeof(chunk.value->'embedding') = 'array'\n      THEN (\n        SELECT ARRAY_AGG(elem.value::float8 ORDER BY elem.ordinality)\n        FROM jsonb_array_elements(chunk.value->'embedding') WITH ORDINALITY AS elem(value, ordinality)\n      )::vector\n      ELSE NULL::vector\n    END AS embedding\n  FROM payload\n  CROSS JOIN LATERAL jsonb_array_elements(payload.chunks_json) WITH ORDINALITY AS chunk(value, ordinality)\n),\ndeleted AS (\n  DELETE FROM kb_chunks WHERE source_id = {{ $json.source_id }} RETURNING 1\n),\ninserted AS (\n  INSERT INTO kb_chunks (source_id, chunk_index, page_number, content, embedding)\n  SELECT\n    source_id,\n    chunk_index,\n    page_number,\n    content,\n    embedding\n  FROM expanded\n  ORDER BY chunk_index\n  RETURNING chunk_index\n),\nsummary AS (\n  SELECT\n    {{ $json.source_id }}::int AS source_id,\n    (SELECT COUNT(*) FROM expanded) AS chunk_count,\n    (SELECT COUNT(*) FROM expanded) AS ok_chunks,\n    0 AS error_chunks\n)\nSELECT\n  summary.source_id,\n  summary.chunk_count,\n  summary.ok_chunks,\n  summary.error_chunks,\n  {{ $json.chunk_text_length || 0 }}::int AS text_length\nFROM summary;\n",
        "options": {}
      },
      "id": "14e7f1c5-b656-42ef-93c1-8e64f59dfc87",
      "name": "Insert KB Chunks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2496,
        112
      ],
      "credentials": {
        "postgres": {
          "id": "j4uy2P7wwsJyISqB",
          "name": "Postgres DrAI"
        }
      }
    },
    {
      "parameters": {
        "command": "=mv \"{{$json[\"file_path\"]}}\" \"{{$json[\"dest_path\"]}}\"\n"
      },
      "id": "3e7d9476-2a57-4199-b784-467634a74e62",
      "name": "Move to Processed",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        2480,
        -96
      ]
    },
    {
      "parameters": {
        "triggerOn": "folder",
        "path": "/data/kb/inbox",
        "events": [
          "add"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.localFileTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "6cb72236-116f-4e59-86d5-ddd3a570a1fa",
      "name": "Watch KB Inbox (File Trigger)"
    },
    {
      "parameters": {},
      "id": "0bc359e4-5a85-44e7-b473-127cec209d38",
      "name": "Prepare File Context",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        416,
        0
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO kb_sources (source_name, source_path)\nVALUES (\n  '{{ String($json.source_name || $json.file_name || \"documento\").replace(/'/g, \"''\") }}',\n  '{{ String($json.source_path || $json.dest_path || $json.file_path || '').replace(/'/g, \"''\") }}'\n)\nRETURNING source_id;",
        "options": {}
      },
      "id": "52e92873-f148-40c4-b5c9-8afc916d2c0b",
      "name": "Insert KB Sources",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        624,
        16
      ],
      "credentials": {
        "postgres": {
          "id": "j4uy2P7wwsJyISqB",
          "name": "Postgres DrAI"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const p = $json.path || '';\nconst name = p.split('/').pop();\nconst ext = name.includes('.') ? name.slice(name.lastIndexOf('.') + 1) : '';\nreturn [{\n  json: {\n    fileName: name,\n    fileExtension: ext,\n    filePath: p\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ],
      "id": "4c9f2af2-2965-4e94-af01-b081028d8f19",
      "name": "Normalize File Info."
    },
    {
      "parameters": {
        "jsCode": "const ctx = $node[\"Prepare File Context\"].json;\n\nreturn [\n  {\n    json: {\n      source_id: $json.source_id,   // viene de Insert KB Sources; sin fallback,\n      source_name: ctx.fileName || \"unknown\",\n      file_name: ctx.fileName || \"unknown\",\n      file_path: ctx.filePath || \"\",\n      dest_path: ctx.filePath ? `/data/kb/processed/${ctx.fileName}` : \"\",\n      extension: (ctx.fileExtension || \"\").toLowerCase(),\n      source_path: ctx.filePath || \"\"\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        832,
        16
      ],
      "id": "4dff8cee-52bb-4833-823f-8ca55be9322b",
      "name": "Prepare Extractor Input"
    },
    {
      "parameters": {
        "functionCode": "// Repack Chunks — combina el embedding devuelto por OpenAI\n// con los metadatos del item original que entró al HTTP,\n// tomándolos del nodo \"Loop Over Items\" (ajusta el nombre si difiere).\n\n// 1) Toma el item original (el que tenía source_id, page_number, content, etc.)\nconst loopItems = $items(\"Loop Over Items\", 0, $runIndex) || [];\nconst original = loopItems[0]?.json || {};\n\n// En tu flujo, los metadatos están bajo original.data.*\n// (si no, usa original.* como fallback)\nconst meta = original.data ?? original;\n\n// 2) Toma la respuesta del HTTP (este nodo ejecuta después del HTTP)\nconst resp = $json;\n\n// Extrae el embedding de la forma estándar del endpoint de OpenAI\n// resp.data[0].embedding\nlet embedding;\nif (Array.isArray(resp?.data) && resp.data[0] && Array.isArray(resp.data[0].embedding)) {\n  embedding = resp.data[0].embedding;\n} else if (Array.isArray(resp?.embedding)) {\n  // fallback por si tienes otra forma\n  embedding = resp.embedding;\n}\n\n// 3) Arma un único chunk con los metadatos + embedding\nconst chunk = {\n  chunk_index: meta.chunk_index ?? 1,\n  page_number: meta.page_number ?? 1,\n  content: meta.content ?? \"\",\n  status: Array.isArray(embedding) ? \"ok\" : \"error\",\n  embedding,\n};\n\n// 4) Devuelve payload para el INSERT\nreturn [{\n  json: {\n    source_id: meta.source_id ?? null,\n    chunks_json: [chunk],\n    chunk_text_length: meta.text_length ?? 0,\n    file_path: meta.file_path ?? null,\n    dest_path: meta.dest_path ?? null,\n  },\n}];\n"
      },
      "id": "8302918c-9976-4cea-bd64-9ed3b60cc869",
      "name": "Repack Chunks",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2160,
        -16
      ],
      "retryOnFail": false,
      "executeOnce": false,
      "alwaysOutputData": false,
      "notesInFlow": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=Authorization",
              "value": "=Bearer {{$env.OPENAI_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": \"{{$json.content || ''}}\"\n}\n",
        "options": {
          "response": {
            "response": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1952,
        -32
      ],
      "id": "3c704dd7-5917-4280-8ac7-91a46f0a62ed",
      "name": "HTTP Request (embeddings)"
    },
    {
      "parameters": {
        "functionCode": "// 1) Leer el binario 'data' como string\nconst bin = $binary.data;\nif (!bin || !bin.data) throw new Error('No llegó binary[data] desde Read/Write Files from Disk.');\n\nconst buff = Buffer.from(bin.data, bin.encoding || 'base64');\nconst text = buff.toString('utf8');\n\n// 2) Parsear JSON grande del extractor\nconst big = JSON.parse(text);\n\n// Estructura esperada: { source_id, file_path, dest_path, page_count, text_length, chunks: [...] }\nconst sourceId = big.source_id || $json.source_id;\n\n// 3) Expandir a items por chunk (stream-friendly)\nconst items = [];\nfor (const c of (big.chunks || [])) {\n  items.push({\n    json: {\n      source_id: sourceId,\n      chunk_index: c.chunk_index,\n      page_number: (c.page_number ?? c.page ?? c.pageIndex ?? c.page_idx) || null,\n      content: c.content || '',\n      status: c.status || 'ok',\n      file_path: big.file_path || null,\n      dest_path: big.dest_path || null,\n      chunk_text_length: big.text_length || 0,\n    },\n  });\n}\n\n// Si por alguna razón vienen 0 chunks, lanzar aviso controlado\nif (items.length === 0) {\n  // Deja al menos un item con metadata para no cortar flujo\n  items.push({ json: { source_id: sourceId, no_chunks: true } });\n}\n\nreturn items;\n"
      },
      "id": "6c125c58-aa0f-4bbe-9920-31d89b778ae0",
      "name": "Binary → JSON",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1568,
        -448
      ],
      "disabled": true
    },
    {
      "parameters": {
        "fileSelector": "={{$json[\"file\"]}}",
        "options": {
          "dataPropertyName": "data"
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        1504,
        -32
      ],
      "id": "ffa4d83d-1f92-4f30-8d94-707ddfc65fce",
      "name": "Read/Write Files from Disk",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "fromJson",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1712,
        -32
      ],
      "id": "2fd1d3e9-9ed3-438b-99d9-5a68e1a81c17",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "jsCode": "return items.map((item, index) => {\n  const input = item.json; // viene de Extract from File (con content, page_number, etc.)\n  const embedding = $json[\"data\"][0][\"embedding\"]; // respuesta de OpenAI\n\n  return {\n    json: {\n      source_id: input.source_id,\n      chunk_index: input.chunk_index,\n      page_number: input.page_number,\n      content: input.content,\n      status: \"ok\",\n      embedding: embedding,\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1376,
        -416
      ],
      "id": "10aaa729-367e-452d-9fbe-8827c6caf091",
      "name": "Code in JavaScript",
      "disabled": true
    }
  ],
  "pinData": {},
  "connections": {
    "Extract & Chunk": {
      "main": [
        [
          {
            "node": "Prepare Chunk Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Chunk Payload": {
      "main": [
        [
          {
            "node": "Read/Write Files from Disk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Watch KB Inbox (File Trigger)": {
      "main": [
        [
          {
            "node": "Normalize File Info.",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare File Context": {
      "main": [
        [
          {
            "node": "Insert KB Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert KB Sources": {
      "main": [
        [
          {
            "node": "Prepare Extractor Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize File Info.": {
      "main": [
        [
          {
            "node": "Prepare File Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Extractor Input": {
      "main": [
        [
          {
            "node": "Extract & Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repack Chunks": {
      "main": [
        [
          {
            "node": "Insert KB Chunks",
            "type": "main",
            "index": 0
          },
          {
            "node": "Move to Processed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request (embeddings)": {
      "main": [
        [
          {
            "node": "Repack Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Binary → JSON": {
      "main": [
        []
      ]
    },
    "Read/Write Files from Disk": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "HTTP Request (embeddings)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        []
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "f0f89525-44a0-4cee-a28b-e6f26fee4b6c",
  "meta": {
    "instanceId": "26c5b7ffa6d42a43f69cb24f731969e90a1796cf64d2684e80f4305e5149b46e"
  },
  "id": "j6YFaFJJAq6TCpeD",
  "tags": []
}